서버 MVC처럼 클라이언트 구현을 위한 구조를 정립하는 것이 목표이다. 

우선 가장 먼저 전체 구성을 Server, Model, View, Template, Event, DOM으로 나누었다.

	[그림]

이 그림에는 각 모듈의 타입을 박스로 표현했으며, 이들 간의 관계를 정의하였다. 
각 박스의 정의는 다음과 같다. 

# 모듈 타입 정의 
## Server
Server는 데이터를 다루는 영역이다. 
JSON으로 데이터 스펙을 맞추어서 실제 서버 구현은 다양한 언어를 사용할 수 있다. 
핵심은 Model을 통해 클라이언트의 다양한 데이터 변화를 수용할 수 있는 서버를 구현하는 것이다. 화면의 요청에 유기적인 응답을 줄 수 있는 구현이 필요하다. 

Server는 Model과만 관계를 가지며, Model을 통해서 데이터를 생성하고 관리하는 데 참여하게 된다. 

## Model
Model은 브라우저에서 데이터를 관리하고, 사용하는 모듈 타입이다. 
DOM으로 표현되는 화면의 데이터는 Model로 조회하며, 저장되고, 변경된다.  이를 위해 View로 전달되는 데이터는 Model로 관리되는 데이터여야 한다. 
Model은 발생한 Event에 맞는 Server를 실행해 데이터는 갱신한다. (조회&수정)

# Template
Template은 화면에 렌더링할 DOM의 틀이다. 쉽게 말해 HTML.
View를 통해서 실행되며, 실행 시점에 Model(=데이터)를 받아서 렌더링을 수행한다. 
화면의 구조를 정의하는 HTML과 데이터를 표현하는 방식이 구분되어 제공되어야 한다.

이렇게 데이터를 바인딩하는 방법은 많은 템플릿 라이브러리들이 제공하며, 본 샘플에서는 dust.js(링크 추가)를 템플릿 라이브러리로 사용한다.

[dust.js 설명 추가]

# View
View는 화면을 제어하기 위한 Dispatcher 역할을 수행한다. 
Event 발생 시 Model변경 후에 화면을 변경하기 위한 요청을 받으며, 이 요청을 받고나서 Template을 사용해 새로운 DOM을 만들고 이를 사용해 화면을 갱신한다. 

# DOM 
실제 화면에 렌더링 되는 객체를 의미한다. Template을 통해서 생성되는 결과물이다.  DOM에서 발생하는 이벤트는 Event로 catch되서 화면과 데이터를 갱신하는 시발점이 된다. 

# Event
브라우저에서 일어나는 모든 행동은 이 Event를 통해서 요청되며, 실행된다.
크게 브라우저에서 발생하는 이벤트를 "바인딩"하고, "실행하는" 부분과 이 Event를 통해서 Model을 변경하는 이벤트로 나뉠 수 있다 


# 코드 설명

## Model (model.js)
Model에 매핑되는 코드로,
Server를 통해 생성되는 JSON 데이터를 가지고 있다 사용할 수 있게 제공한다. 
현재는 Read만 샘플만 있다. 
Model이 변경되는 유형 별로 함수를 정의해 이벤트에서 이를 바인딩할 수 있게 제공한다. 

	[code]

# Event (event.js)
매핑되어 있는 Event 실행 시에 (event-function 바인딩 로직을 다사 정제해야겠다!)
실행되는 함수 정의 Model과 View로 발생한 이벤트를 전달하는 역할을 한다. 

현재는 event를 바인딩하는 로직이 아닌 event에 실행하는 로직만 들어가 있다. 

	[code]

# View
Template을 사용해 렌더링을 수행해서 실제 화면에 DOM을 뿌리는 역할을 함.
공통으로 계속 사용할 클래스.

# Template
Dust.js를 사용해 구현한 클래스 
실제 화면에 렌더링되는 DOM을 생성하는 클래스
View 영역 별로 만들어야 함 

# Server(JSON)
임시로 만든 파일..
얼마든지 Server 구현 언어를 적용해 교체 가능
단, 콘텐츠 타입(데이터 타입)을 맞추면 된다! 

# app.html
아직까지는 박스에 등장하지 않은 코드이다.
여기에 나온 JavaScript는 사용할 변수를 선언하고, 이벤트를 실제로 바인딩하는 코드가 들어가 있다. 
리팩터링이 가장 많이 되야 하는 코드이다. 
